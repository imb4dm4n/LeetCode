# README

## purpose

- This repository is for practice only.



## 4 两个有序数组的中位数

- 问题分析：先合并两个数组， 需要找到他们的边界。
- 思路：
  - 合并数组a，b：
    - 情况 a 所有的值都小于 b
      - 顺序合并 a，b
    - a所有的值都大于b
      - 合并b，a
    - a的最大值大于b的最小值，但是 小于b的最大值
      - [  aaaa [bbb  ]aaabbb   ]
      - 找到a中
  - 用两个整数id_a, id_b，分别记录当前正在读取的数组的偏移。 当他们是中位数偏移时， break。
  - 先计算两个数组总过有多少数字count， 判定中位数的偏移是奇数，还是偶数（两数之和除以二）
    - 基数：
      - 中位数偏移 count/2 + 1
      - 
    - 偶数：
      - 中位数偏移 count/2，count/2 + 1

## 最长回文

- 原理：
  	对称的字符串有的特性：
  以中轴字符起，左右两个字符都相同。 相同意味着用 xor 得到0 。
  进一步加速，可以把字符转为 short 、 int 、 long long 数字进行对比。

- 无非就是想确定， 对称发生的字符的偏移量a， 对称结束的字符偏移量b，  b -a 得到对称长度，构造字符串，从b开始 2*(b-a) 长。
  
- 剩下的就是去探测，哪里开始不对称。 从最优情况，就是最中间开始， 假设整个字符串是对称的，因此在最远处的两个字符应该是相同的， 若不是，则对称字符长度减一。 
  
  
  
- 实现：
  字符串长度 n
  需要记录最长子串长， 因为每个中轴索引，都有 n/2 种可能的长度。
  或者不这样， 从长到短去寻找， 意思是遍历所有对称串可能长度的子串，如果没有发现，
  则减少对称串的长度。 

- 先从字符串最中间开始找，如果左右都相同，则找到，如果不是对称的，则设置 offset 
  
- 需要3个索引： 中轴索引，根据中轴推出左右两个子串的每个字符索引。 中轴索引都会有相应的
  对称点，因此需要生成两次。
  一个对称长度，记录对称串的长度

  子串生成 -》 对称判断函数

  最后根据中轴索引和对称串长度，得到 对称串起始地址和结束地址。

###  判断字符串是否对称

#### 栈

- 如果字符串对称， 那么在中间点之前入栈， 中间点之后出栈时，字符是相同的。

  - ~~~
    abcdcba
    a-b-c-d 出栈 d - c - b - a
    ~~~

  - 



## 链表

### swap nodes pair

- https://leetcode.com/problems/swap-nodes-in-pairs

- 思路：
  - 核心思想是修改当前节点的 next 和 下一个节点的 next。
  - 需要修复前一对节点的后一个节点的 next 为 交换后的新的当前节点。
    - 如1-2-3-4  第一次交换 2-1-3-4 。 下一步交换 3-4得到 （2-1）（4-3），但是 1 的next指针是3，因此需要修复1的next为4 。

### rotate list

- https://leetcode.com/problems/rotate-list/
- 循环移位链表k次。 类似 汇编指令的 ror ，不同的是数据不同而已。
- 思路：
  - 核心问题： 新的头节点、 移位的节点位置，它的前节点 next 修改， 移位的后半段链表最后一个节点的next修改。
  - 通过指针数组快速做一次O（n）的遍历即可。

